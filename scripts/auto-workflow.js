#!/usr/bin/env node
/**
 * è‡ªå‹•ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼çµ±åˆã‚·ã‚¹ãƒ†ãƒ 
 * æŒ‡ç¤ºã«åŸºã¥ã„ã¦è‡ªå‹•çš„ã«worktreeä½œæˆã€é–‹ç™ºã€ãƒ†ã‚¹ãƒˆã€PRä½œæˆã€ãƒ¬ãƒ“ãƒ¥ãƒ¼ã€ãƒãƒ¼ã‚¸ã‚’å®Ÿè¡Œ
 */

import { Octokit } from '@octokit/rest';
import { execSync, spawn } from 'child_process';
import fs from 'fs';
import path from 'path';
import chalk from 'chalk';
import dotenv from 'dotenv';

dotenv.config();

class AutoWorkflowOrchestrator {
  constructor() {
    this.octokit = new Octokit({
      auth: process.env.GITHUB_TOKEN
    });
    
    this.config = {
      owner: process.env.GITHUB_OWNER || '20m61',
      repo: process.env.GITHUB_REPO || 'lightningtalk-circle',
      baseBranch: 'main',
      worktreeBase: '../lightningtalk-worktrees',
      autoMerge: process.env.AUTO_MERGE === 'true',
      requireReview: process.env.REQUIRE_REVIEW !== 'false'
    };

    this.log = {
      info: (msg) => console.log(chalk.blue('â„¹ï¸ '), msg),
      success: (msg) => console.log(chalk.green('âœ…'), msg),
      warning: (msg) => console.log(chalk.yellow('âš ï¸ '), msg),
      error: (msg) => console.log(chalk.red('âŒ'), msg),
      step: (msg) => console.log(chalk.cyan('ğŸ”„'), msg)
    };
  }

  /**
   * æŒ‡ç¤ºã‚’è§£æã—ã¦ã‚¿ã‚¹ã‚¯ã‚’ç‰¹å®š
   */
  parseInstruction(instruction) {
    const patterns = {
      // æ©Ÿèƒ½é–‹ç™º
      feature: /(?:add|implement|create|build)\s+(.+?)(?:\s+feature|\s+functionality|$)/i,
      // ãƒã‚°ä¿®æ­£
      bugfix: /(?:fix|resolve|repair)\s+(.+?)(?:\s+bug|\s+issue|$)/i,
      // ãƒ›ãƒƒãƒˆãƒ•ã‚£ãƒƒã‚¯ã‚¹
      hotfix: /(?:hotfix|urgent|critical)\s+(.+)/i,
      // ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°
      refactor: /(?:refactor|improve|optimize)\s+(.+)/i,
      // ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆ
      docs: /(?:document|doc|documentation)\s+(.+)/i,
      // ãƒ†ã‚¹ãƒˆ
      test: /(?:test|testing)\s+(.+)/i
    };

    for (const [type, pattern] of Object.entries(patterns)) {
      const match = instruction.match(pattern);
      if (match) {
        return {
          type,
          description: match[1].trim(),
          branchName: this.generateBranchName(type, match[1].trim()),
          originalInstruction: instruction
        };
      }
    }

    // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ feature ã¨ã—ã¦æ‰±ã†
    return {
      type: 'feature',
      description: instruction,
      branchName: this.generateBranchName('feature', instruction),
      originalInstruction: instruction
    };
  }

  /**
   * ãƒ–ãƒ©ãƒ³ãƒåã‚’ç”Ÿæˆ
   */
  generateBranchName(type, description) {
    const sanitized = description
      .toLowerCase()
      .replace(/[^a-z0-9\s-]/g, '')
      .replace(/\s+/g, '-')
      .substring(0, 50);
    
    const timestamp = Date.now().toString().slice(-6);
    return `${type}/${sanitized}-${timestamp}`;
  }

  /**
   * worktreeã‚’ä½œæˆ
   */
  async createWorktree(branchName) {
    this.log.step(`Creating worktree for branch: ${branchName}`);
    
    try {
      const worktreeName = branchName.replace('/', '-');
      const worktreePath = path.join(this.config.worktreeBase, worktreeName);
      
      // Worktreeãƒ‡ã‚£ãƒ¬ã‚¯ãƒˆãƒªãŒå­˜åœ¨ã—ãªã„å ´åˆã¯ä½œæˆ
      if (!fs.existsSync(this.config.worktreeBase)) {
        fs.mkdirSync(this.config.worktreeBase, { recursive: true });
      }

      // Git worktreeã‚’ä½œæˆ
      execSync(`git worktree add -b ${branchName} ${worktreePath}`, { stdio: 'inherit' });
      
      // å¿…è¦ãªãƒ•ã‚¡ã‚¤ãƒ«ã‚’ã‚³ãƒ”ãƒ¼
      if (fs.existsSync('.env.example')) {
        fs.copyFileSync('.env.example', path.join(worktreePath, '.env'));
      }

      this.log.success(`Worktree created at: ${worktreePath}`);
      return { worktreePath, worktreeName };
    } catch (error) {
      this.log.error(`Failed to create worktree: ${error.message}`);
      throw error;
    }
  }

  /**
   * é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
   */
  async executeDevelopmentTask(task, worktreePath) {
    this.log.step(`Executing development task: ${task.description}`);
    
    const originalCwd = process.cwd();
    process.chdir(worktreePath);

    try {
      // ã‚¿ã‚¹ã‚¯ã‚¿ã‚¤ãƒ—ã«åŸºã¥ã„ã¦é©åˆ‡ãªå‡¦ç†ã‚’å®Ÿè¡Œ
      switch (task.type) {
        case 'feature':
          await this.implementFeature(task);
          break;
        case 'bugfix':
          await this.fixBug(task);
          break;
        case 'hotfix':
          await this.implementHotfix(task);
          break;
        case 'refactor':
          await this.performRefactoring(task);
          break;
        case 'docs':
          await this.updateDocumentation(task);
          break;
        case 'test':
          await this.addTests(task);
          break;
        default:
          await this.implementFeature(task);
      }

      this.log.success('Development task completed');
    } finally {
      process.chdir(originalCwd);
    }
  }

  /**
   * æ©Ÿèƒ½å®Ÿè£…
   */
  async implementFeature(task) {
    // å®Ÿè£…ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
    const featureTemplate = `
// ${task.description}
// Generated by Auto Workflow System

/**
 * ${task.description}
 * 
 * @description ${task.originalInstruction}
 * @created ${new Date().toISOString()}
 */

// TODO: Implement ${task.description}
console.log('Feature: ${task.description}');

export default {
  name: '${task.description}',
  implemented: false,
  // Add your implementation here
};
`;

    const featureDir = 'src/features';
    if (!fs.existsSync(featureDir)) {
      fs.mkdirSync(featureDir, { recursive: true });
    }

    const fileName = task.description.toLowerCase().replace(/\s+/g, '-') + '.js';
    fs.writeFileSync(path.join(featureDir, fileName), featureTemplate);

    // package.jsonã‚’æ›´æ–°ï¼ˆå¿…è¦ã«å¿œã˜ã¦ï¼‰
    this.updatePackageJson(task);
  }

  /**
   * ãƒã‚°ä¿®æ­£
   */
  async fixBug(task) {
    // ãƒã‚°ä¿®æ­£ã®ãƒ†ãƒ³ãƒ—ãƒ¬ãƒ¼ãƒˆ
    const bugfixLog = `
# Bug Fix: ${task.description}

## Issue Description
${task.originalInstruction}

## Root Cause Analysis
- TODO: Identify root cause

## Solution
- TODO: Implement fix

## Testing
- TODO: Add regression tests

Fixed on: ${new Date().toISOString()}
`;

    if (!fs.existsSync('bugfixes')) {
      fs.mkdirSync('bugfixes');
    }

    const logFile = `bugfixes/${task.description.toLowerCase().replace(/\s+/g, '-')}.md`;
    fs.writeFileSync(logFile, bugfixLog);
  }

  /**
   * ãƒ›ãƒƒãƒˆãƒ•ã‚£ãƒƒã‚¯ã‚¹å®Ÿè£…
   */
  async implementHotfix(task) {
    // ç·Šæ€¥æ€§ã‚’ç¤ºã™ãƒãƒ¼ã‚«ãƒ¼ãƒ•ã‚¡ã‚¤ãƒ«ã‚’ä½œæˆ
    const hotfixInfo = {
      description: task.description,
      instruction: task.originalInstruction,
      priority: 'CRITICAL',
      createdAt: new Date().toISOString(),
      requiresImmediateReview: true
    };

    fs.writeFileSync('HOTFIX.json', JSON.stringify(hotfixInfo, null, 2));
    await this.implementFeature(task);
  }

  /**
   * ãƒªãƒ•ã‚¡ã‚¯ã‚¿ãƒªãƒ³ã‚°å®Ÿè¡Œ
   */
  async performRefactoring(task) {
    const refactorLog = `
# Refactoring: ${task.description}

## Objective
${task.originalInstruction}

## Changes Made
- TODO: Document changes

## Performance Impact
- TODO: Measure performance improvements

## Breaking Changes
- TODO: List any breaking changes

Refactored on: ${new Date().toISOString()}
`;

    fs.writeFileSync('REFACTORING.md', refactorLog);
  }

  /**
   * ãƒ‰ã‚­ãƒ¥ãƒ¡ãƒ³ãƒˆæ›´æ–°
   */
  async updateDocumentation(task) {
    const docPath = 'docs/auto-generated';
    if (!fs.existsSync(docPath)) {
      fs.mkdirSync(docPath, { recursive: true });
    }

    const docContent = `
# ${task.description}

## Overview
${task.originalInstruction}

## Details
TODO: Add detailed documentation

## Usage Examples
TODO: Add usage examples

---
*Auto-generated on ${new Date().toISOString()}*
`;

    const fileName = task.description.toLowerCase().replace(/\s+/g, '-') + '.md';
    fs.writeFileSync(path.join(docPath, fileName), docContent);
  }

  /**
   * ãƒ†ã‚¹ãƒˆè¿½åŠ 
   */
  async addTests(task) {
    const testTemplate = `
import { describe, it, expect } from '@jest/globals';

describe('${task.description}', () => {
  it('should ${task.description.toLowerCase()}', () => {
    // TODO: Implement test for ${task.description}
    expect(true).toBe(true);
  });

  it('should handle edge cases', () => {
    // TODO: Add edge case tests
    expect(true).toBe(true);
  });
});

// Auto-generated test on ${new Date().toISOString()}
`;

    const testDir = 'tests/auto-generated';
    if (!fs.existsSync(testDir)) {
      fs.mkdirSync(testDir, { recursive: true });
    }

    const fileName = task.description.toLowerCase().replace(/\s+/g, '-') + '.test.js';
    fs.writeFileSync(path.join(testDir, fileName), testTemplate);
  }

  /**
   * package.jsonæ›´æ–°
   */
  updatePackageJson(task) {
    try {
      const packagePath = 'package.json';
      if (fs.existsSync(packagePath)) {
        const packageData = JSON.parse(fs.readFileSync(packagePath, 'utf8'));
        
        // ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’è¿½åŠ 
        if (!packageData.scripts) packageData.scripts = {};
        
        const scriptName = task.description.toLowerCase().replace(/\s+/g, '-');
        packageData.scripts[scriptName] = `echo "Running ${task.description}"`;

        fs.writeFileSync(packagePath, JSON.stringify(packageData, null, 2));
      }
    } catch (error) {
      this.log.warning(`Could not update package.json: ${error.message}`);
    }
  }

  /**
   * è‡ªå‹•ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
   */
  async runAutomatedTests(worktreePath) {
    this.log.step('Running automated tests...');
    
    const originalCwd = process.cwd();
    process.chdir(worktreePath);

    try {
      // è¤‡æ•°ã®æ–¹æ³•ã§ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œã—ã€ã‚ˆã‚Šå …ç‰¢ã«ã™ã‚‹
      const testResults = await this.executeTestsWithRetry();
      
      if (testResults.success) {
        this.log.success('All tests passed');
        return true;
      } else {
        this.log.error(`Tests failed: ${testResults.error}`);
        return false;
      }
    } catch (error) {
      this.log.error(`Test execution failed: ${error.message}`);
      return false;
    } finally {
      process.chdir(originalCwd);
    }
  }

  /**
   * ãƒªãƒˆãƒ©ã‚¤æ©Ÿèƒ½ä»˜ããƒ†ã‚¹ãƒˆå®Ÿè¡Œ
   */
  async executeTestsWithRetry(maxRetries = 3) {
    let lastError;
    
    for (let attempt = 1; attempt <= maxRetries; attempt++) {
      this.log.info(`Test attempt ${attempt}/${maxRetries}`);
      
      try {
        // ã¾ãš Docker ãŒåˆ©ç”¨å¯èƒ½ã‹ãƒã‚§ãƒƒã‚¯
        const dockerAvailable = await this.checkDockerAvailability();
        
        if (dockerAvailable) {
          this.log.info('Using Docker test environment');
          await this.runDockerTests();
        } else {
          this.log.warning('Docker not available, falling back to local tests');
          await this.runLocalTests();
        }
        
        return { success: true };
        
      } catch (error) {
        lastError = error;
        this.log.warning(`Attempt ${attempt} failed: ${error.message}`);
        
        if (attempt < maxRetries) {
          const delay = Math.pow(2, attempt) * 1000; // Exponential backoff
          this.log.info(`Retrying in ${delay/1000} seconds...`);
          await new Promise(resolve => setTimeout(resolve, delay));
        }
      }
    }
    
    return { 
      success: false, 
      error: `All ${maxRetries} attempts failed. Last error: ${lastError.message}` 
    };
  }

  /**
   * Docker ã®åˆ©ç”¨å¯èƒ½æ€§ã‚’ãƒã‚§ãƒƒã‚¯
   */
  async checkDockerAvailability() {
    try {
      execSync('docker --version', { stdio: 'pipe' });
      
      // Docker Compose ãƒ•ã‚¡ã‚¤ãƒ«ã®å­˜åœ¨ç¢ºèª
      const dockerComposeFile = '../lightningtalk-circle/docker-compose.dev.yml';
      if (!fs.existsSync(dockerComposeFile)) {
        this.log.warning('Docker Compose file not found');
        return false;
      }
      
      // Docker daemon ãŒå‹•ä½œã—ã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      execSync('docker info', { stdio: 'pipe' });
      
      return true;
    } catch (error) {
      this.log.warning(`Docker not available: ${error.message}`);
      return false;
    }
  }

  /**
   * Docker ç’°å¢ƒã§ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
   */
  async runDockerTests() {
    const dockerComposeFile = '../lightningtalk-circle/docker-compose.dev.yml';
    
    try {
      // ãƒ†ã‚¹ãƒˆç’°å¢ƒã‚’æº–å‚™
      this.log.info('Preparing Docker test environment...');
      execSync(`docker-compose -f ${dockerComposeFile} pull test-runner`, { 
        stdio: 'pipe',
        timeout: 120000 // 2åˆ†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
      });
      
      // ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
      this.log.info('Running tests in Docker container...');
      const output = execSync(
        `docker-compose -f ${dockerComposeFile} run --rm test-runner npm test`, 
        { 
          encoding: 'utf8',
          timeout: 300000, // 5åˆ†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
          maxBuffer: 1024 * 1024 // 1MB ãƒãƒƒãƒ•ã‚¡
        }
      );
      
      // ãƒ†ã‚¹ãƒˆçµæœã®è§£æ
      if (output.includes('FAIL') || output.includes('FAILED')) {
        throw new Error('Some tests failed in Docker environment');
      }
      
      this.log.success('Docker tests completed successfully');
      
    } catch (error) {
      // Docker ç’°å¢ƒã®ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      try {
        execSync(`docker-compose -f ${dockerComposeFile} down`, { stdio: 'pipe' });
      } catch (cleanupError) {
        this.log.warning(`Failed to cleanup Docker environment: ${cleanupError.message}`);
      }
      
      throw new Error(`Docker test execution failed: ${error.message}`);
    }
  }

  /**
   * ãƒ­ãƒ¼ã‚«ãƒ«ç’°å¢ƒã§ã®ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
   */
  async runLocalTests() {
    try {
      this.log.info('Running tests in local environment...');
      
      // ã¾ãšä¾å­˜é–¢ä¿‚ãŒã‚¤ãƒ³ã‚¹ãƒˆãƒ¼ãƒ«ã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      if (!fs.existsSync('node_modules')) {
        this.log.info('Installing dependencies...');
        execSync('npm install', { 
          stdio: 'inherit',
          timeout: 300000 // 5åˆ†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
        });
      }
      
      // ãƒ­ãƒ¼ã‚«ãƒ«ãƒ†ã‚¹ãƒˆå®Ÿè¡Œ
      const output = execSync('npm test', { 
        encoding: 'utf8',
        timeout: 180000, // 3åˆ†ã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆ
        maxBuffer: 1024 * 1024 // 1MB ãƒãƒƒãƒ•ã‚¡
      });
      
      // ãƒ†ã‚¹ãƒˆçµæœã®è§£æ
      if (output.includes('FAIL') || output.includes('FAILED')) {
        throw new Error('Some tests failed in local environment');
      }
      
      this.log.success('Local tests completed successfully');
      
    } catch (error) {
      throw new Error(`Local test execution failed: ${error.message}`);
    }
  }

  /**
   * å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
   */
  async commitChanges(task, worktreePath) {
    this.log.step('Committing changes...');
    
    const originalCwd = process.cwd();
    process.chdir(worktreePath);

    try {
      execSync('git add .', { stdio: 'inherit' });
      
      const commitMessage = `${task.type}: ${task.description}

${task.originalInstruction}

ğŸ¤– Generated with Auto Workflow System

Co-Authored-By: Claude <noreply@anthropic.com>`;

      execSync(`git commit -m "${commitMessage}"`, { stdio: 'inherit' });
      execSync(`git push -u origin ${task.branchName}`, { stdio: 'inherit' });
      
      this.log.success('Changes committed and pushed');
    } finally {
      process.chdir(originalCwd);
    }
  }

  /**
   * ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆä½œæˆ
   */
  async createPullRequest(task) {
    this.log.step('Creating pull request...');

    try {
      const prTitle = `${task.type.charAt(0).toUpperCase() + task.type.slice(1)}: ${task.description}`;
      const prBody = `## Summary
${task.originalInstruction}

## Changes
- Implemented ${task.description}
- Added automated tests
- Updated documentation as needed

## Type of Change
- [${task.type === 'feature' ? 'x' : ' '}] New feature
- [${task.type === 'bugfix' ? 'x' : ' '}] Bug fix
- [${task.type === 'hotfix' ? 'x' : ' '}] Hotfix
- [${task.type === 'refactor' ? 'x' : ' '}] Refactoring
- [${task.type === 'docs' ? 'x' : ' '}] Documentation
- [${task.type === 'test' ? 'x' : ' '}] Tests

## Testing
- [x] Automated tests pass
- [x] Manual testing completed

## Checklist
- [x] Code follows project style guidelines
- [x] Self-review completed
- [x] Tests added/updated
- [x] Documentation updated

ğŸ¤– Auto-generated with [Claude Code](https://claude.ai/code)

Co-Authored-By: Claude <noreply@anthropic.com>`;

      const labels = this.getPRLabels(task);

      const { data: pr } = await this.octokit.pulls.create({
        owner: this.config.owner,
        repo: this.config.repo,
        title: prTitle,
        body: prBody,
        head: task.branchName,
        base: this.config.baseBranch
      });

      // ãƒ©ãƒ™ãƒ«ã‚’è¿½åŠ 
      if (labels.length > 0) {
        await this.octokit.issues.addLabels({
          owner: this.config.owner,
          repo: this.config.repo,
          issue_number: pr.number,
          labels
        });
      }

      this.log.success(`Pull request created: ${pr.html_url}`);
      return pr;
    } catch (error) {
      this.log.error(`Failed to create pull request: ${error.message}`);
      throw error;
    }
  }

  /**
   * PRãƒ©ãƒ™ãƒ«ã‚’å–å¾—
   */
  getPRLabels(task) {
    const labelMap = {
      feature: ['enhancement', 'feature'],
      bugfix: ['bug', 'fix'],
      hotfix: ['hotfix', 'urgent'],
      refactor: ['refactor', 'code-quality'],
      docs: ['documentation'],
      test: ['testing']
    };

    return labelMap[task.type] || ['enhancement'];
  }

  /**
   * è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼å®Ÿè¡Œ
   */
  async performAutomatedReview(pr, task) {
    this.log.step('Performing automated review...');

    try {
      // ã‚³ãƒ¼ãƒ‰å“è³ªãƒã‚§ãƒƒã‚¯
      const qualityChecks = await this.runQualityChecks(task.branchName);
      
      // ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
      const securityChecks = await this.runSecurityScan(task.branchName);
      
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
      const performanceChecks = await this.runPerformanceTests(task.branchName);

      const reviewComments = [];
      
      if (!qualityChecks.passed) {
        reviewComments.push(`âŒ **Code Quality Issues:**\n${qualityChecks.issues.join('\n')}`);
      } else {
        reviewComments.push(`âœ… **Code Quality:** All checks passed`);
      }

      if (!securityChecks.passed) {
        reviewComments.push(`âŒ **Security Issues:**\n${securityChecks.issues.join('\n')}`);
      } else {
        reviewComments.push(`âœ… **Security:** No issues found`);
      }

      if (!performanceChecks.passed) {
        reviewComments.push(`âš ï¸ **Performance:**\n${performanceChecks.issues.join('\n')}`);
      } else {
        reviewComments.push(`âœ… **Performance:** Within acceptable limits`);
      }

      const allChecksPassed = qualityChecks.passed && securityChecks.passed && performanceChecks.passed;
      
      const reviewBody = `## Automated Review Results

${reviewComments.join('\n\n')}

## Overall Assessment
${allChecksPassed ? 'âœ… **APPROVED** - All automated checks passed' : 'âŒ **CHANGES REQUESTED** - Issues found that need attention'}

---
ğŸ¤– This review was performed automatically by the Auto Workflow System`;

      // ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’æŠ•ç¨¿
      await this.octokit.pulls.createReview({
        owner: this.config.owner,
        repo: this.config.repo,
        pull_number: pr.number,
        body: reviewBody,
        event: allChecksPassed ? 'APPROVE' : 'REQUEST_CHANGES'
      });

      this.log.success(`Automated review completed: ${allChecksPassed ? 'APPROVED' : 'CHANGES REQUESTED'}`);
      return { approved: allChecksPassed, pr };
    } catch (error) {
      this.log.error(`Automated review failed: ${error.message}`);
      throw error;
    }
  }

  /**
   * ã‚³ãƒ¼ãƒ‰å“è³ªãƒã‚§ãƒƒã‚¯
   */
  async runQualityChecks(branchName) {
    try {
      // ESLintã‚„Prettierãªã©ã®å“è³ªãƒã‚§ãƒƒã‚¯ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      const issues = [];
      
      // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ã€å®Ÿéš›ã®lintãƒ„ãƒ¼ãƒ«ã‚’å®Ÿè¡Œ
      this.log.info('Running code quality checks...');
      
      return {
        passed: true,
        issues
      };
    } catch (error) {
      return {
        passed: false,
        issues: [error.message]
      };
    }
  }

  /**
   * ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³
   */
  async runSecurityScan(branchName) {
    try {
      this.log.info('Running security scan...');
      
      // npm auditã‚„ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£ã‚¹ã‚­ãƒ£ãƒ³ã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      return {
        passed: true,
        issues: []
      };
    } catch (error) {
      return {
        passed: false,
        issues: [error.message]
      };
    }
  }

  /**
   * ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ
   */
  async runPerformanceTests(branchName) {
    try {
      this.log.info('Running performance tests...');
      
      // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆã‚’ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ãƒˆ
      return {
        passed: true,
        issues: []
      };
    } catch (error) {
      return {
        passed: false,
        issues: [error.message]
      };
    }
  }

  /**
   * è‡ªå‹•ãƒãƒ¼ã‚¸å®Ÿè¡Œ
   */
  async performAutoMerge(pr) {
    if (!this.config.autoMerge) {
      this.log.info('Auto-merge is disabled. PR ready for manual merge.');
      return false;
    }

    this.log.step('Performing auto-merge validation...');

    try {
      // ãƒãƒ¼ã‚¸å‰ã®è©³ç´°ãªæ¤œè¨¼
      const mergeValidation = await this.validateMergeConditions(pr);
      
      if (!mergeValidation.canMerge) {
        this.log.warning(`Auto-merge blocked: ${mergeValidation.reason}`);
        return false;
      }

      this.log.step('All merge conditions met. Proceeding with auto-merge...');

      // ãƒãƒ¼ã‚¸å®Ÿè¡Œ
      await this.octokit.pulls.merge({
        owner: this.config.owner,
        repo: this.config.repo,
        pull_number: pr.number,
        commit_title: `${mergeValidation.prData.title} (#${pr.number})`,
        commit_message: this.generateMergeCommitMessage(mergeValidation.prData),
        merge_method: 'squash'
      });

      this.log.success(`PR #${pr.number} merged successfully`);
      return true;
    } catch (error) {
      this.log.error(`Auto-merge failed: ${error.message}`);
      return false;
    }
  }

  /**
   * ãƒãƒ¼ã‚¸æ¡ä»¶ã‚’è©³ç´°ã«æ¤œè¨¼
   */
  async validateMergeConditions(pr) {
    try {
      // PR ã®è©³ç´°æƒ…å ±ã‚’å–å¾—
      const { data: prData } = await this.octokit.pulls.get({
        owner: this.config.owner,
        repo: this.config.repo,
        pull_number: pr.number
      });

      // åŸºæœ¬çš„ãªãƒãƒ¼ã‚¸å¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯
      if (!prData.mergeable) {
        return {
          canMerge: false,
          reason: 'PR has merge conflicts that need to be resolved manually'
        };
      }

      if (prData.mergeable_state !== 'clean') {
        return {
          canMerge: false,
          reason: `PR mergeable state is '${prData.mergeable_state}', expected 'clean'`
        };
      }

      // CI/CD ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯
      const statusChecks = await this.checkRequiredStatusChecks(pr);
      if (!statusChecks.allPassed) {
        return {
          canMerge: false,
          reason: `Required status checks not passed: ${statusChecks.failedChecks.join(', ')}`
        };
      }

      // ãƒ¬ãƒ“ãƒ¥ãƒ¼æ‰¿èªãƒã‚§ãƒƒã‚¯
      if (this.config.requireReview) {
        const reviewStatus = await this.checkReviewApproval(pr);
        if (!reviewStatus.approved) {
          return {
            canMerge: false,
            reason: reviewStatus.reason
          };
        }
      }

      // ãƒ–ãƒ©ãƒ³ãƒä¿è­·ãƒ«ãƒ¼ãƒ«ãƒã‚§ãƒƒã‚¯
      const branchProtection = await this.checkBranchProtectionRules(prData.base.ref);
      if (!branchProtection.canMerge) {
        return {
          canMerge: false,
          reason: branchProtection.reason
        };
      }

      // è¿½åŠ ã®å®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯
      const safetyChecks = await this.performSafetyChecks(prData);
      if (!safetyChecks.safe) {
        return {
          canMerge: false,
          reason: safetyChecks.reason
        };
      }

      return {
        canMerge: true,
        prData,
        reason: 'All merge conditions satisfied'
      };

    } catch (error) {
      return {
        canMerge: false,
        reason: `Failed to validate merge conditions: ${error.message}`
      };
    }
  }

  /**
   * å¿…é ˆã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ãƒã‚§ãƒƒã‚¯ã‚’ç¢ºèª
   */
  async checkRequiredStatusChecks(pr) {
    try {
      const { data: statuses } = await this.octokit.repos.getCombinedStatusForRef({
        owner: this.config.owner,
        repo: this.config.repo,
        ref: pr.head.sha
      });

      const failedChecks = statuses.statuses
        .filter(status => status.state !== 'success')
        .map(status => status.context);

      return {
        allPassed: statuses.state === 'success',
        failedChecks
      };
    } catch (error) {
      this.log.warning(`Could not fetch status checks: ${error.message}`);
      return {
        allPassed: false,
        failedChecks: ['Status check verification failed']
      };
    }
  }

  /**
   * ãƒ¬ãƒ“ãƒ¥ãƒ¼æ‰¿èªçŠ¶æ³ã‚’ãƒã‚§ãƒƒã‚¯
   */
  async checkReviewApproval(pr) {
    try {
      const { data: reviews } = await this.octokit.pulls.listReviews({
        owner: this.config.owner,
        repo: this.config.repo,
        pull_number: pr.number
      });

      const latestReviews = new Map();
      
      // å„ãƒ¬ãƒ“ãƒ¥ã‚¢ãƒ¼ã®æœ€æ–°ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å–å¾—
      reviews.forEach(review => {
        if (!latestReviews.has(review.user.login) || 
            new Date(review.submitted_at) > new Date(latestReviews.get(review.user.login).submitted_at)) {
          latestReviews.set(review.user.login, review);
        }
      });

      const approvals = Array.from(latestReviews.values()).filter(review => review.state === 'APPROVED');
      const changesRequested = Array.from(latestReviews.values()).filter(review => review.state === 'CHANGES_REQUESTED');

      if (changesRequested.length > 0) {
        return {
          approved: false,
          reason: 'Changes requested in reviews'
        };
      }

      if (approvals.length === 0) {
        return {
          approved: false,
          reason: 'No approving reviews found'
        };
      }

      return {
        approved: true,
        approvals: approvals.length
      };

    } catch (error) {
      return {
        approved: false,
        reason: `Could not check review status: ${error.message}`
      };
    }
  }

  /**
   * ãƒ–ãƒ©ãƒ³ãƒä¿è­·ãƒ«ãƒ¼ãƒ«ã‚’ãƒã‚§ãƒƒã‚¯
   */
  async checkBranchProtectionRules(baseBranch) {
    try {
      const { data: protection } = await this.octokit.repos.getBranchProtection({
        owner: this.config.owner,
        repo: this.config.repo,
        branch: baseBranch
      });

      // å¿…è¦ãªä¿è­·ãƒ«ãƒ¼ãƒ«ãŒã™ã¹ã¦æº€ãŸã•ã‚Œã¦ã„ã‚‹ã‹ãƒã‚§ãƒƒã‚¯
      if (protection.required_status_checks && protection.required_status_checks.strict) {
        // Strict mode requires branch to be up to date
        // ã“ã®å ´åˆã¯è¿½åŠ ã®ãƒã‚§ãƒƒã‚¯ãŒå¿…è¦
      }

      return {
        canMerge: true
      };

    } catch (error) {
      if (error.status === 404) {
        // ãƒ–ãƒ©ãƒ³ãƒä¿è­·ãŒè¨­å®šã•ã‚Œã¦ã„ãªã„å ´åˆã¯ OK
        return { canMerge: true };
      }
      
      return {
        canMerge: false,
        reason: `Could not verify branch protection rules: ${error.message}`
      };
    }
  }

  /**
   * è¿½åŠ ã®å®‰å…¨æ€§ãƒã‚§ãƒƒã‚¯
   */
  async performSafetyChecks(prData) {
    const issues = [];

    // PR ãŒå¤§ãã™ããªã„ã‹ãƒã‚§ãƒƒã‚¯
    if (prData.additions + prData.deletions > 1000) {
      issues.push('PR is very large (>1000 lines changed)');
    }

    // å±é™ºãªãƒ•ã‚¡ã‚¤ãƒ«ã®å¤‰æ›´ã‚’ãƒã‚§ãƒƒã‚¯
    try {
      const { data: files } = await this.octokit.pulls.listFiles({
        owner: this.config.owner,
        repo: this.config.repo,
        pull_number: prData.number
      });

      const criticalFiles = files.filter(file => 
        file.filename.includes('package.json') ||
        file.filename.includes('.github/workflows/') ||
        file.filename.includes('docker-compose') ||
        file.filename.includes('Dockerfile')
      );

      if (criticalFiles.length > 0) {
        issues.push(`Critical files modified: ${criticalFiles.map(f => f.filename).join(', ')}`);
      }

    } catch (error) {
      issues.push('Could not verify changed files');
    }

    return {
      safe: issues.length === 0,
      reason: issues.length > 0 ? issues.join('; ') : 'All safety checks passed'
    };
  }

  /**
   * ãƒãƒ¼ã‚¸ã‚³ãƒŸãƒƒãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’ç”Ÿæˆ
   */
  generateMergeCommitMessage(prData) {
    return `
Automated merge of ${prData.head.ref} into ${prData.base.ref}

${prData.body || 'No description provided'}

Merged automatically by Auto Workflow System
- PR: #${prData.number}
- Author: ${prData.user.login}
- Commits: ${prData.commits}
- Files changed: ${prData.changed_files}
`.trim();
  }

  /**
   * worktreeã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
   */
  async cleanupWorktree(worktreePath, branchName, merged = false) {
    this.log.step('Cleaning up worktree...');

    try {
      // worktreeã‚’å‰Šé™¤
      execSync(`git worktree remove ${worktreePath}`, { stdio: 'inherit' });

      // ãƒãƒ¼ã‚¸æ¸ˆã¿ã®å ´åˆã¯ãƒ–ãƒ©ãƒ³ãƒã‚‚å‰Šé™¤
      if (merged) {
        execSync(`git branch -d ${branchName}`, { stdio: 'inherit' });
        execSync(`git push origin --delete ${branchName}`, { stdio: 'inherit' });
      }

      this.log.success('Worktree cleanup completed');
    } catch (error) {
      this.log.warning(`Cleanup warning: ${error.message}`);
    }
  }

  /**
   * ãƒ¡ã‚¤ãƒ³ãƒ¯ãƒ¼ã‚¯ãƒ•ãƒ­ãƒ¼å®Ÿè¡Œ
   */
  async executeWorkflow(instruction) {
    this.log.info(`ğŸš€ Starting automated workflow for: "${instruction}"`);
    
    try {
      // 1. æŒ‡ç¤ºã‚’è§£æ
      const task = this.parseInstruction(instruction);
      this.log.info(`ğŸ“‹ Task identified: ${task.type} - ${task.description}`);

      // 2. Worktreeã‚’ä½œæˆ
      const { worktreePath, worktreeName } = await this.createWorktree(task.branchName);

      // 3. é–‹ç™ºã‚¿ã‚¹ã‚¯ã‚’å®Ÿè¡Œ
      await this.executeDevelopmentTask(task, worktreePath);

      // 4. è‡ªå‹•ãƒ†ã‚¹ãƒˆã‚’å®Ÿè¡Œ
      const testsPass = await this.runAutomatedTests(worktreePath);
      if (!testsPass) {
        throw new Error('Automated tests failed');
      }

      // 5. å¤‰æ›´ã‚’ã‚³ãƒŸãƒƒãƒˆ
      await this.commitChanges(task, worktreePath);

      // 6. ãƒ—ãƒ«ãƒªã‚¯ã‚¨ã‚¹ãƒˆã‚’ä½œæˆ
      const pr = await this.createPullRequest(task);

      // 7. è‡ªå‹•ãƒ¬ãƒ“ãƒ¥ãƒ¼ã‚’å®Ÿè¡Œ
      const reviewResult = await this.performAutomatedReview(pr, task);

      // 8. æ‰¿èªã•ã‚ŒãŸå ´åˆã¯è‡ªå‹•ãƒãƒ¼ã‚¸
      let merged = false;
      if (reviewResult.approved) {
        merged = await this.performAutoMerge(pr);
      }

      // 9. ã‚¯ãƒªãƒ¼ãƒ³ã‚¢ãƒƒãƒ—
      await this.cleanupWorktree(worktreePath, task.branchName, merged);

      this.log.success(`ğŸ‰ Workflow completed successfully!`);
      this.log.info(`ğŸ“Š Summary:`);
      this.log.info(`   - Task: ${task.description}`);
      this.log.info(`   - PR: ${pr.html_url}`);
      this.log.info(`   - Status: ${merged ? 'MERGED' : 'PENDING REVIEW'}`);

      return {
        success: true,
        task,
        pr,
        merged,
        message: 'Workflow executed successfully'
      };

    } catch (error) {
      this.log.error(`âŒ Workflow failed: ${error.message}`);
      return {
        success: false,
        error: error.message,
        message: 'Workflow execution failed'
      };
    }
  }
}

// CLIå®Ÿè¡Œéƒ¨åˆ†
if (import.meta.url === `file://${process.argv[1]}`) {
  const instruction = process.argv[2];
  
  if (!instruction) {
    console.log(`
Usage: node auto-workflow.js "<instruction>"

Examples:
  node auto-workflow.js "add user authentication feature"
  node auto-workflow.js "fix login bug"
  node auto-workflow.js "refactor database connection"
  node auto-workflow.js "document API endpoints"
`);
    process.exit(1);
  }

  const orchestrator = new AutoWorkflowOrchestrator();
  orchestrator.executeWorkflow(instruction)
    .then(result => {
      console.log('\n' + chalk.green('='.repeat(50)));
      console.log(chalk.green('WORKFLOW EXECUTION COMPLETE'));
      console.log(chalk.green('='.repeat(50)));
      process.exit(result.success ? 0 : 1);
    })
    .catch(error => {
      console.error(chalk.red('Fatal error:'), error.message);
      process.exit(1);
    });
}

export default AutoWorkflowOrchestrator;